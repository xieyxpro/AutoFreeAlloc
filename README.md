# AutoFreeAlloc

C/C++最被人诟病的，可能是没有一个内存垃圾回收器（确切是说没有一个标准的垃圾回收器）。这个小玩意要点是，在C/C++中实现一个最袖珍的、功能受限的内存分配和垃圾回收器。这个垃圾回收器区别于其他垃圾回收器的主要特征是：

  1.  **袖珍但具实用性。** 整个垃圾回收器代码行数100行左右（不含空白行），相当小巧。相对而言，它的功能也受到一定的限制。但是它在很多关键的场合恰恰非常有用。该垃圾回收器以实用作为首要目标。
  2.  **高性能。** 区别于其他垃圾回收器的是这个袖珍的垃圾回收器非但不会导致性能的下降，反而提高了程序的时间性能（分配的速度加快）和空间性能（所占内存空间比正常的malloc/new少）。而这也是实用的重要指标。

## 思路
**这个内存分配和垃圾回收器的关键点在于，是在于理解它的目标：为一个复杂的局部过程（算法）提供自动内存回收的能力。**

局部过程（算法），是指那些算法复杂性较高，但在程序运行期所占的时间又比较短暂的过程。例如：搜索引擎的搜索过程、读盘/存盘过程、显示（绘制）过程等等。通常这些过程可能需要申请很多内存，而且内存分配操作的入口点很多（就是调用new的地方很多），如果每调用一次new就要考虑应该在什么地方delete就徒然浪费我们宝贵的脑力，使得我们无法把全力精力集中在算法本身的设计上。也许就是在这种情形下，C/C++程序员特别羡慕那些具备垃圾回收器的语言。相对而言，如果算法复杂性不高的话，我们的程序员完全有能力控制好new/delete的匹配关系。并且，这种“一切皆在我掌控之中”的感觉给了我们安全感和满足感。　

因此， **这个垃圾回收器的重心并不是要提供一个理论上功能完备的内存自动回收机制。它只是针对复杂性较高的局部过程（算法），为他们提供最实效的内存管理手段。从局部过程的一开始，你就只管去申请、使用内存，等到整个算法完成之后，这个过程申请的大部分内存（需要作为算法结果保留的例外），无论它是在算法的那个步骤申请的，均在这个结束点上由垃圾回收器自动销毁。** 示意图如下：

![image](http://cplusplus.wikidot.com/local--files/cn:auto-alloc/1.gif)

## 细节
我把这个分配器命名为 AutoAlloc。它的接口很简单，仅涉及两个概念：allocate、clear。
